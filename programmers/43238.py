"""
# 프로그래머스 입국심사 문제
- 43248번

총 n명의 인원이 있다.
각 창구는 각 인원을 처리하는데 정해진 시간이 걸린다.

이때, n명이 모두 입국심사를 마치는 최소 시간을 구하는 알고리즘을 작성해야 한다.
나는 처음에는 이를 그리디하게 해결하고자 했으나, 어떻게 구현해야할 지 감이 잡히지 않았다.

그러니까, k초부터 1초씩 더해가며 시뮬레이션할 생각을 했고, 머릿속이 복잡해져갔다.
처음에 여러 빈 창구에는 어떻게 인원을 배치하지?
시간이 지나기 전에 비어 있는 모든 창구에 인원을 배치하면 되나? 이런 알고리즘이라면,
무조건 비어 있는 창구에 배치하는 알고리즘 밖에 되지 않을 텐데? 이러면 4, [1, 10]의 상황을 대응할 수 없음.
왜냐하면 먼 미래를 보지 않고 처음에 1, 10 시간이 걸리는 창구에 인원을 집어넣을 테니까.

그래서,,, 정말 많은 고민을 했고, 도저히 해결되지 않아(며칠 고민했던 것 같음) GPT에 물어봤다.
우선순위 큐를 써서 가장 빨리 끝나는 창구를 선택하면 된다고.
힙에 끝나는 시간을 저장해두면 가장 빨리 끝나는 창구를 꺼내 쓸 것이다.
그리고 그 창구가 끝난 다음의 정보도 힙에 넣어두는 것이다.

(5, [1, 5])의 상황을 생각해보자.
1. (1, 1), (5, 5)를 처음에 힙에 넣는다. 튜플의 첫 번째 요소는 해당 창구가 끝나는 시간, 두 번째 요소는 해당 창구가 처리하는데 걸리는 시간(저장해둬야 나중에 쓰기 때문)
2. 그럼 인원 1명이 들어가서 나오는 과정을 생각해볼 수 있다(순차적으로 이루어지는데, 실제 상황에선 병렬로 사람을 처리하잖아... 이 생각의 간극은 어떻게 해결해야 할까? 잘 이해가 되지 않긴 하네)
3. 인원 A가 들어가서 가장 빠르게 나올 수 있는 경우는 (1, 1)이고, 이제 걸린 시간 1에 걸릴 예정인 시간 1을 더해 (2, 1)을 다시 힙에 넣는다.
4. 이제 인원 B를 생각해보자. 내가 초반에 제시했던 알고리즘이라면 5분 걸리는 창구가 비어 있으니까 바로 들어갔을 테지만, 또 (2, 1)이라는 창구를 보고 여기에 진입한다. 그리고 (3, 1)을 다시 힙에 넣는다.
5. 인원 C도 마찬가지. (3, 1)을 빼고 (4, 1)을 넣는다.
6. 인원 D도 마찬가지. (4, 1)을 빼고 (5, 1)을 넣는다.
7. 인원 E도 마찬가지. (5, 1)을 빼고 (6, 1)을 넣는다.
8. 이제 끝이다. E가 끝난 마지막 시간 5초를 정답으로 하고, 이 알고리즘이라면 어느 창구에 배치될지에 대한 것도 확인할 수 있다.

그렇다면 이제 (6, [1, 5])의 상황을 생각해보자.
1. 처음에 (1, 1), (5, 5)가 들어갈 것
2. 인원 A가 들어가서 (1, 1)을 빼고 (2, 1)을 넣음
3. 인원 B가 들어가서 (2, 1)을 빼고 (3, 1)을 넣음
4. 인원 C가 들어가서 (3, 1)을 빼고 (4, 1)을 넣음
5. 인원 D가 들어가서 (4, 1)을 빼고 (5, 1)을 넣음
6. 인원 E가 들어가서 (5, 1)을 빼고 (6, 1)을 넣음
7. 인원 F가 들어가서 **이때가 중요하다** 5분 걸리던 창구에게도 기회가 왔다! (5, 5)를 뺴고 (10, 5)를 넣는다.
8. 이제 끝이다 결국 5초만에 6명의 인원을 모두 처리할 수 있다.

사실 이 알고리즘을 실제 스케줄링하는데 쓸 수는 없을 것이다. 이미 배치되고 나서의 시간을 미리 계산하고 힙에서 빼는 것이고, 실제로 그 시점에서 어느 창구에 들어가서 연산을 수행할지 결정하는 알고리즘은 아니기 때문이다.
"""
print("첫 번째 풀이!")

import heapq

def solution(n, times):
    answer = 0
    heap = []

    for t in times:
        heapq.heappush(heap, (t, t))
    
    for _ in range(n):
        elapsed_time, process_time = heapq.heappop(heap)
        answer = elapsed_time
        heapq.heappush(heap, ((elapsed_time + process_time), process_time))
    
    return answer

print(solution(6, [7, 10]))
print(solution(5, [1, 5]))
print(solution(6, [1, 5]))

"""
그러나! 제출해서 테스트해보면 시간이 초과된다.

조건을 보면 n은 1,000,000,000명 이하이다...
게다가 각 창구에서 한 명을 심사하는데 걸리는 시간도 1분 이상 1,000,000,000분 이하이다.
더군다나 창구는 100,000개 이하이다...

이걸 해결하기 위해서 더 효과적인 알고리즘이 필요할 것이다.
그래서 이 문제의 분류가 이진탐색으로 되어 있었던 것이다...

자, 그럼 이진탐색으로 이것을 어떻게 해결할 수 있을지 생각해보자.
1. 가장 적게 시간이 걸리는 경우: 아무도 없을 때, 0분
2. 가장 오래 시간이 걸리는 경우: 가장 느린 처리 시간을 가진 창구에 모두가 몰렸을 때, max(times) * n
위의 두 범위를 이분탐색하여, 해당 시간으로 모든 창구들이 그 시간 내에 처리를 할 수 있는지 검사한다.

예를 들어, (6, [7, 10])이 있다고 해보자.
0분 ~ 60분 사이의 시간이 걸릴 것이다.
그 중간을 잡아보자 (0 + 60) // 2 = 30분. 30분 안에 처리 가능한가? 이것을 알아보기 위해
7분이 걸리는 창구는 30분안에 4명 처리할 수 있고, 10분이 걸리는 창구는 3명 처리할 수 있다. 총 7명을 처리할 수 있기에 6명을 처리하는데 충분하다.
30분이라는 시간이 충분하니까 더 줄여보자. (0 + 30) // 2 = 15분. 15분 안에 처리 가능한가?
7분이 걸리는 창구 -> 2명, 10분이 걸리는 창구 -> 1명, 총 3명 처리할 수 있으니까 불가능하다.
그렇다면 15분~30분으로 범위가 좁혀졌다. 처리에 실패하면 기준 시간을 left 변수로 잡으면 될 것이다.
또 중간을 잡아보자 (15 + 30) // 2 = 22분.
7분이 걸리는 창구 -> 3명, 10분이 걸리는 창구 -> 2명, 총 5명 처리할 수 있으니 불가능하다(5 <= n).
left를 22로 잡고 또 중간을 찾아보자. (22 + 30) // 2 = 26분.
7분이 걸리는 창구 -> 3명, 10분이 걸리는 창구 -> 2명, 마찬가지이다.
left를 26으로 잡고 (26 + 30) // 2 = 28분.
7분이 걸리는 창구 -> 4명, 10분이 걸리는 창구 -> 2명, 6명 가능하다! 충분히 처리 가능하다.
26을 right로 두자. 그럼! 같아진다. 이런 조건에서 종료하면 될 것이다.

근데 종료 조건에 대해 의심해봐야할 것이다. right가 left보다 작거나 같을 때 종료해야 하나? 그렇다면 무엇이 답인가?
right가 left보다 작아질 수 있나?

나의 논리대로라면 해당 시간으로 인원을 처리할 수 없으면 시간을 늘린다. 즉 left를 그 시간으로 설정한다.
해당 시간으로 인원을 처리할 수 있으면 시간을 줄인다. 즉 right를 그 시간으로 설정한다.
그리고 그 중간을 잡아 그 시간으로 처리할 수 있는지 검사를 해보는 것이다.
(left + right) // 2를 구하고 이게 left가 될 수도 right가 될 수도 있는 것이다.
사실 그러면 left와 right가 역전되는 일은 없을 것이다.
left 20 right 21이라면 20이 그 중간 값이고 left, right가 같아지면 같아졌지 역전될 일은 없을 듯.
그래도 혹시 모르니 같거나 역전되는 상황에서 종료하면 될 것으로 보인다.
"""
print("두 번째 풀이!")

def solution(n, times):
    left = 0
    right = max(times) * n

    while left < right:
        middle = (left + right) // 2
        n_limit = 0

        for t in times:
            n_limit += middle // t
        
        if n_limit < n:  # 처리할 수 없으면
            left = middle + 1  # 어차피 이 middle로 처리할 수 없으니까 1을 증가시킨다. 무한루프 빠지는 것 방지.
        else:  # 처리할 수 있으면
            right = middle

    return right

print(solution(6, [7, 10]))
print(solution(5, [1, 5]))
print(solution(6, [1, 5]))
